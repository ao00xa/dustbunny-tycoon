#include <hidef.h>      /* common defines and macros */
#include "derivative.h"      /* derivative-specific definitions */

#include "graphics.h" //Drawing functions
#include "interface.h" //Serial interface

#include "paddle.h"
#include "chkbtnasm.h"

#include "displayScores.h"

#define ever (;;)

paddle p1_aloc;
paddle p2_aloc;

paddle *p1 = &p1_aloc;
paddle *p2 = &p2_aloc;

//Ball data
int ball_x_min;
int ball_y_min;
int ball_x_max;
int ball_y_max;

int ball_dir_y;
int ball_dir_x;
char ball_wait_to_die;

#define P_HEIGHT 8
#define P_WIDTH 36
#define BALL_R 16

unsigned int lfsr = 0xACE1; 
unsigned int rand()
{
	//Return a random value
	//Pseudo random numbers generated by linear feedback shift register

	unsigned int bit;
	bit  = ((lfsr >> 0) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5) ) & 1;
	lfsr =  (lfsr >> 1) | (bit << 15);
	
	return lfsr;
}

void ball_init()
{
	char l = 6;
	char s = 3;
	unsigned int cx = 240/2 - 94;
	unsigned int cy = 320/2;
	int fillcolor = GetRGB(0, 0, 0);

	ball_x_min = cx - BALL_R;
	ball_x_max = cx + BALL_R;
	
	ball_y_min = cy - BALL_R;
	ball_y_max = cy + BALL_R;
	
	ball_dir_x = 4;
	
	// Randomize the y direction
	if(rand() % 2)
	{
		ball_dir_y = 6;
	}
	else
	{
		ball_dir_y = -6;
	}
	
	
	ball_wait_to_die = 0;
	
	//Basic ball
	OLED_DrawCircle(cx, cy , BALL_R - 7, 0, GetRGB(255, 255, 255));
	
	
	//Triangle patches of the pentagon
	OLED_DrawTriangle(
		cx - s, cy - l, 
		cx - (s+l - 2), cy, 
		cx, cy, 
		fillcolor);
	OLED_DrawTriangle(
		cx + l, cy - s, 
		cx - s, cy - l, 
		cx, cy, 
		fillcolor);
	OLED_DrawTriangle(
		cx + l, cy - s, 
		cx, cy, 
		cx + l, cy + s, 
		fillcolor);
	OLED_DrawTriangle(
		cx, cy, 
		cx - s, cy + l, 
		cx + l, cy + s, 
		fillcolor);
	OLED_DrawTriangle(
		cx - (s+l - 2), cy, 
		cx - s, cy + l, 
		cx, cy, 
		fillcolor);

	// Seams
	OLED_DrawLine(
		cx - (s+l - 2), cy, 
		cx - (s+l - 2) - 5, cy, 
		fillcolor);
	OLED_DrawLine(
		cx - s, cy - l,
		cx - s*3, cy - l*3,
		fillcolor);
	OLED_DrawLine(
		cx + l, cy - s, 
		cx + l*3, cy - s*3, 
		fillcolor);
	OLED_DrawLine(
		cx + l, cy + s, 
		cx + l*3, cy + s*3, 
		fillcolor);
	OLED_DrawLine(
		cx - s, cy + l, 
		cx - s*3, cy + l*3, 
		fillcolor);
}

char ball_move(int speedfactor)
{
	char switch_dir = 0;

	//Check side bounce
	if(ball_x_min + ball_dir_x < 0 || ball_x_max + ball_dir_x > 240)
	{
		ball_dir_x = -ball_dir_x;
	}
	
	//See if the ball has been lost 
	if(ball_y_min + ball_dir_y < 0)
	{
		return -1;
	}
	
	else if(ball_y_max + ball_dir_y > 320)
	{
		return 1;
	}
	
	// See if the ball is in the p1 'court'
	if(ball_y_min + ball_dir_y <= p1->y + p1->height && ~ball_wait_to_die)
	{
		if(p1->x > ball_x_max || p1->x + p1->width < ball_x_min)
		{
			//Player has missed
			ball_wait_to_die = 1;
		}
		else
		{
			//Player is has saved
			switch_dir = 1;
		}
	}
	
	// See if the ball is in the p2 'court'
	if(ball_y_max + ball_dir_y >= p2->y && ~ball_wait_to_die)
	{
		if(p2->x > ball_x_max || p2->x + p2->width < ball_x_min)
		{
			//Player has missed
			ball_wait_to_die = 1;
		}
		else
		{
			//Player is has saved
			switch_dir = -1;
		}
	}
	
	//Peform bounce off of paddle
	if(switch_dir)
	{
		//Add some randomness to the balls direction
		switch(rand() % 8)
		{
			// Normal
			case 0:
			{
				ball_dir_y = 4*switch_dir;
				ball_dir_x = 4*(1 - 2*(((unsigned int)ball_dir_x) >> 15));
				break;	
			}
			// Faster in y
			case 1: 
			{
				ball_dir_y = 6*switch_dir;
				ball_dir_x = 4*(1 - 2*(((unsigned int)ball_dir_x)>> 15));
				break;	
			}
			// Faster in x
			case 2:
			{
				ball_dir_y = 4*switch_dir;
				ball_dir_x = 6*(1 - 2*(((unsigned int)ball_dir_x) >> 15));
				break;	
			}
			// Even faster in y
			case 3: 
			{
				ball_dir_y = 7*switch_dir;
				ball_dir_x = 4*(1 - 2*(((unsigned int)ball_dir_x)>> 15));
				break;	
			}
			// Even faster in x
			case 4:
			{
				ball_dir_y = 4*switch_dir;
				ball_dir_x = 7*(1 - 2*(((unsigned int)ball_dir_x) >> 15));
				break;	
			}
			//No speed change
			default: ball_dir_y = -ball_dir_y; break;
		}
	}

	//Do the screen copy
	OLED_CopyPaste(	ball_x_min, ball_y_min,
					ball_x_min + (ball_dir_x*1000)/speedfactor, ball_y_min + (ball_dir_y*1000)/speedfactor, 
					2*BALL_R + 1,
					2*BALL_R + 1);
	
	//Update position variables				
	ball_x_min += (ball_dir_x*1000)/speedfactor;
	ball_x_max += (ball_dir_x*1000)/speedfactor;
	
	ball_y_min += (ball_dir_y*1000)/speedfactor;
	ball_y_max += (ball_dir_y*1000)/speedfactor;
	
	return 0;
}

void main(void) 
{
	char result = 0;
	
	//Variables for delays
	unsigned int temp = 0;
	unsigned int temp2 = 0;

	EnableInterrupts;
	
	DDRB = 0x01; // Not really needed -> just need pb0
	DDRA = 0x0F; // For keypannel

	//Basic initialization
	SCI_Init();
	OLED_Init();
	initLCD();
	updatedisplay();
	
	//Initialize the paddle structures
	paddle_init(p1, PADDLE_RIGHT, P_WIDTH, P_HEIGHT);
	paddle_init(p2, PADDLE_LEFT, P_WIDTH, P_HEIGHT);
	
	for ever //Valley girl style
	{
		//Clear the screen for full redraw
		OLED_Clear();
		
		//Draw the player paddles, one red the other blue
		paddle_draw(p1, 4, 1, GetRGB(255,0,0));
		paddle_draw(p2, 4, 1, GetRGB(0,0,255));
		
		//Draw the ball
		ball_init();
		
		result = 0;
		
		//A brief delay for the players to recoup
		for(temp2=0; temp2 < 300; temp2++) 
		for(temp=0; temp < 50000; temp++) {}
		
		while(result == 0)
		{
			char p1move;
			char p2move;
			int speedfactor = 1800;
			
			p1move = chkbtn(4, 1);
			p2move = chkbtn(4, 4);
		
			paddle_move(p1, p1move);
			paddle_move(p2, p2move);
		
			//Speed the ball up if copy-paste commands have been sent for the paddles
			if(p1move) speedfactor -= 400;
			if(p2move) speedfactor -= 400;
		
			result = ball_move(speedfactor);
		}
		
		if(result > 0)
		{
			rscored();
		}
		else if(result < 0)
		{
			lscored();
		}
		
		updatedisplay();
	}
}
